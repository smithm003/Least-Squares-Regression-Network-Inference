import numpy as np
import random
from scipy.special import gamma, factorial
from scipy.stats import levy_stable


# Sum of Pareto variables

def ymin_one(alpha):
    #Determine the lower cutoff ymin such that E[y]=1, where y ~ ParetoI
    if alpha>1:
        res=(alpha-1)/alpha #from Pareto distribution - ensures E[y_min}=1 at res]
    elif alpha==1:
        res=1 #The mean is ill-defined for alpha=1, but this is fine because the frequency dynamics is independent of the choice of ymin
    return res

def ParetoI(alpha,ymin, size):
    #ParetoI is genered from ParetoII generated by np.random.pareto
    return ymin*(1+np.random.pareto(alpha,size=size)) #generates samples from Pareto II distribution, then shifts to give Pareto I
    

def stable_a(alpha,ymin,M): #ensure stable distribution
    c = np.power(ymin,alpha) #raises all the variables y_min to the corresponding power of alpha
    if alpha<1 and alpha>0: #is alpha is a fraction, just default res to 0
        res=0
    elif alpha==1: #if alpha is one, 
        res = c*M*np.log(M)
    elif alpha>1:
        res = M*ymin*alpha/(alpha-1)
 
    return res

def stable_b(alpha,ymin,M):
    
    c = np.power(ymin,alpha)
    
    if alpha<1 and alpha>0:
        res=np.power(np.pi*M*c/(2*gamma(alpha) *np.sin(np.pi*alpha/2)) ,1/alpha)
    elif alpha==1:
        res = np.pi*M*c/2
    elif alpha>1 and alpha<2:
        res = np.power(np.pi*M*c/(2*gamma(alpha) *np.sin(np.pi*alpha/2)) ,1/alpha)
    elif alpha==2:
        res = np.power(c*M*np.log(M),0.5)
    elif alpha>2:
        var = (ymin**2)*alpha/(((alpha-1)**2)*(alpha-2))
        res = np.power(M*0.5*var,0.5)
    
    return res
    
def rv_paretosum(alpha,ymin,M):
    #Compute the sum Y of M ParetoI variables y
    if M<1000:
        #When M is small 
        Y = np.sum(ParetoI(alpha,ymin, size=M))
    else:
        if alpha<2:
            rand=levy_stable.rvs(alpha, beta=1, loc=0, scale=1, size=1, random_state=None)[0]
        if alpha>=2:
            rand=levy_stable.rvs(2, beta=1, loc=0, scale=1, size=1, random_state=None)[0]
        Y = stable_a(alpha,ymin,M)+ rand*stable_b(alpha,ymin,M)   
    return Y

def WF_pareto_sim(alpha, Npop,counts_per_demeweek, ND, T, A=None,Nmicrolins=400, freqini=[]):
    
    if A is None:
        print('A is not provided! A_demo is used.')
        if ND==2:
            A=np.array([[0.6,0.4],[0.2,0.8]])
        if ND==3:
            A=np.array([[0.6,0.25,0.15],[0.2,0.8,0.0],[0.1,0.05,0.85]])

        if ND>3:
            A = np.zeros((ND,ND))
            for i in range(ND):
                for j in range(ND):
                    A[i,j]=np.random.pareto(1)
                A[i,i] += 2*np.sum(A[i])
                A[i]*=1.0/np.sum(A[i])
    else:
        A = A
    
    if type(Npop)==int:
        NS=np.array([Npop]*ND) #Controls the strength of stochasticity (in transition probability)
        n=np.min([400,Npop]) # total number of sublineages.
    else:# if the list of Npop is provided
        NS = Npop 
        n=np.min([Nmicrolins,np.min(Npop)])

    if type(counts_per_demeweek)==int:
        counts_deme=np.ones((ND,T))*counts_per_demeweek
    else:
        counts_deme=counts_per_demeweek
        

    
    B=np.zeros((T,n,ND))
    if freqini ==[]: 
        for i in range(ND):
            #aux=np.random.dirichlet([1]*n, size = 1)[0]#np.ones(n)/n
            aux=np.random.pareto(a=1.5, size=n)#Assume a power-law intitial distribution
            aux = aux/np.sum(aux)
            B[0,:,i]=np.random.multinomial(NS[i], aux, size=1)/NS[i]
    else:
        for i in range(ND):
            B[0,:,i]=freqini[i,:]
        
        # B[0,:,i]= np.array([1.0/n]*n)
        
    if alpha!=0:
        ymin=ymin_one(alpha)
    for t in range(1,T):
        aux = B[t-1,:,:].T
        aux = np.matmul(A,aux)
    
        for i in range(ND):
            if alpha!=0:# WF for alpha=0
                aux[i] = np.array([rv_paretosum(alpha,ymin,(int)(NS[i]*aux[i,k])) for k in range(n)])
                aux[i] *=1.0/np.sum(aux[i])
            B[t,:,i] =np.random.multinomial(NS[i],aux[i], size=1)/NS[i]
            
            #B[t,:,i] = np.array([freq_after_jackpot_pseudo(aux[i,k],lst_offsp,NS[i]) for k in range(n)])
            #B[t,:,i]=np.random.multinomial(NS[i], aux[i], size=1)/NS[i]   
    
    counts=np.zeros(B.shape)
    for i in range(T):
            for j in range(ND):
                counts[i,:,j]  =np.random.multinomial(counts_deme[j,i], B[i,:,j], size=1)
    counts=counts.transpose([2,1,0])
    
    return A,counts



def WF_sim(Npop,counts_per_demeweek, Csn, ND, T, A=None,Ntraj=100, freqini=[]):
    
    if A is None:
        print('A is not provide! A_demo is used.')
        if ND==2:
            A=np.array([[0.6,0.4],[0.2,0.8]])
        if ND==3:
            A=np.array([[0.6,0.25,0.15],[0.2,0.8,0.0],[0.1,0.05,0.85]])

        if ND>3:
            A = np.zeros((ND,ND))
            for i in range(ND):
                for j in range(ND):
                    A[i,j]=np.random.pareto(1)
                A[i,i] += 2*np.sum(A[i])
                A[i]*=1.0/np.sum(A[i])
    else:
        A = A
    
    if type(Npop)==int:
        NS=np.array([Npop]*ND) #Controls the strength of stochasticity (in transition probability)
    else:# if the list of Npop is provided
        NS = Npop 
    
    B=np.zeros((T,Ntraj,ND))
    
    if freqini ==[]: 
        for i in range(ND):
            aux=np.random.pareto(a=10, size=Ntraj)#Assume a power-law intitial distribution
            aux = aux/np.sum(aux)
            B[0,:,i]=np.random.multinomial(NS[i], aux, size=1)/NS[i]
    else:
        for i in range(ND):
            B[0,:,i]=freqini[i,:]
        
    for t in range(1,T):
        aux = B[t-1,:,:].T
        aux = np.matmul(A,aux)
        for l in range(Ntraj): 
            for i in range(ND):
                B[t,l,i] =np.random.binomial(NS[i],aux[i,l], size=1)/NS[i]
 
    # Add sampling error
    if type(counts_per_demeweek)==int:
        counts_deme=np.ones((ND,T))*counts_per_demeweek
    else:
        counts_deme=counts_per_demeweek
    counts=np.zeros(B.shape)
    for t in range(T):
            for j in range(ND):
                for l in range(Ntraj):
                    if Csn[j] !=0:
                        counts[t,l,j]  =np.round(np.random.binomial(int(counts_deme[j,t]/Csn[j]), B[t,l,j], size=1)*Csn[j])
                    else:
                        counts[t,l,j]  = B[t,l,j]*counts_deme[j,t]
    counts=counts.transpose([2,1,0])

    return A,counts,B
